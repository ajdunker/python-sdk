# coding: utf-8

"""
    IdentityNow cc (private) APIs

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from typing import Any, ClassVar, Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictInt, StrictStr
from pydantic import Field
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class ListConnectors200ResponseItemsInner(BaseModel):
    """
    ListConnectors200ResponseItemsInner
    """

  # noqa: E501
    application_xml: Optional[StrictStr] = Field(default=None,
                                                 alias="applicationXml")
    class_name: Optional[StrictStr] = Field(default=None, alias="className")
    connector_metadata: Optional[Union[str,
                                       Any]] = Field(default=None,
                                                     alias="connectorMetadata")
    correlation_config_xml: Optional[StrictStr] = Field(
        default=None, alias="correlationConfigXml")
    direct_connect: Optional[StrictBool] = Field(default=None,
                                                 alias="directConnect")
    file_upload: Optional[StrictBool] = Field(default=None, alias="fileUpload")
    id: Optional[StrictInt] = None
    name: Optional[StrictStr] = None
    s3_location: Optional[StrictStr] = Field(default=None, alias="s3Location")
    scope: Optional[StrictStr] = None
    script_name: Optional[StrictStr] = Field(default=None, alias="scriptName")
    source_config: Optional[StrictStr] = Field(default=None,
                                               alias="sourceConfig")
    source_config_from: Optional[StrictStr] = Field(default=None,
                                                    alias="sourceConfigFrom")
    source_config_xml: Optional[StrictStr] = Field(default=None,
                                                   alias="sourceConfigXml")
    status: Optional[StrictStr] = None
    translation_properties: Optional[Union[str, Any]] = Field(
        default=None, alias="translationProperties")
    type: Optional[StrictStr] = None
    uploaded_files: Optional[List[Union[str,
                                        Any]]] = Field(default=None,
                                                       alias="uploadedFiles")
    __properties: ClassVar[List[str]] = [
        "applicationXml", "className", "connectorMetadata",
        "correlationConfigXml", "directConnect", "fileUpload", "id", "name",
        "s3Location", "scope", "scriptName", "sourceConfig",
        "sourceConfigFrom", "sourceConfigXml", "status",
        "translationProperties", "type", "uploadedFiles"
    ]

    model_config = {"populate_by_name": True, "validate_assignment": True}

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of ListConnectors200ResponseItemsInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        # set to None if application_xml (nullable) is None
        # and model_fields_set contains the field
        if self.application_xml is None and "application_xml" in self.model_fields_set:
            _dict['applicationXml'] = None

        # set to None if class_name (nullable) is None
        # and model_fields_set contains the field
        if self.class_name is None and "class_name" in self.model_fields_set:
            _dict['className'] = None

        # set to None if correlation_config_xml (nullable) is None
        # and model_fields_set contains the field
        if self.correlation_config_xml is None and "correlation_config_xml" in self.model_fields_set:
            _dict['correlationConfigXml'] = None

        # set to None if s3_location (nullable) is None
        # and model_fields_set contains the field
        if self.s3_location is None and "s3_location" in self.model_fields_set:
            _dict['s3Location'] = None

        # set to None if source_config (nullable) is None
        # and model_fields_set contains the field
        if self.source_config is None and "source_config" in self.model_fields_set:
            _dict['sourceConfig'] = None

        # set to None if source_config_from (nullable) is None
        # and model_fields_set contains the field
        if self.source_config_from is None and "source_config_from" in self.model_fields_set:
            _dict['sourceConfigFrom'] = None

        # set to None if source_config_xml (nullable) is None
        # and model_fields_set contains the field
        if self.source_config_xml is None and "source_config_xml" in self.model_fields_set:
            _dict['sourceConfigXml'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of ListConnectors200ResponseItemsInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "applicationXml":
            obj.get("applicationXml"),
            "className":
            obj.get("className"),
            "connectorMetadata":
            obj.get("connectorMetadata"),
            "correlationConfigXml":
            obj.get("correlationConfigXml"),
            "directConnect":
            obj.get("directConnect"),
            "fileUpload":
            obj.get("fileUpload"),
            "id":
            obj.get("id"),
            "name":
            obj.get("name"),
            "s3Location":
            obj.get("s3Location"),
            "scope":
            obj.get("scope"),
            "scriptName":
            obj.get("scriptName"),
            "sourceConfig":
            obj.get("sourceConfig"),
            "sourceConfigFrom":
            obj.get("sourceConfigFrom"),
            "sourceConfigXml":
            obj.get("sourceConfigXml"),
            "status":
            obj.get("status"),
            "translationProperties":
            obj.get("translationProperties"),
            "type":
            obj.get("type"),
            "uploadedFiles":
            obj.get("uploadedFiles")
        })
        return _obj
